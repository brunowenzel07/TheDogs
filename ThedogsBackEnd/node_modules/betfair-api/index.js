var _ = require('lodash');
var fs = require('fs');
var async = require('async');
var request = require('request');
var config = require(process.cwd() + '/config/exchanges').betfair;

// https://api.developer.betfair.com/services/webapps/docs/display/1smk3cen4v3lu3yomq5qye0ni/Market+Data+Request+Limits
var maxRequestLimit = 200;
var requestLimits = {
  listMarketCatalogue: {
    applyTo: 'marketProjection',
    MARKET_DESCRIPTION: 1,
    RUNNER_DESCRIPTION: 0,
    EVENT:	0,
    EVENT_TYPE:	0,
    COMPETITION: 0,
    RUNNER_METADATA: 1,
    MARKET_START_TIME: 0
  },
  listMarketBook: {
    applyTo: 'priceProjection.priceData',
    NONE: 2,
    SP_AVAILABLE: 3,
    SP_TRADED: 7,
    EX_BEST_OFFERS: 5,
    EX_ALL_OFFERS: 17,
    EX_TRADED: 17
  },
  listMarketProfitAndLoss: {
    NONE: 4
  }
};

// Api Request Mappings
var apiRequests = [
  { name: 'cancelOrders', method: 'cancelOrders', endpoint: 'betting' },
  { name: 'listClearedOrders', method: 'listClearedOrders', endpoint: 'betting' },
  { name: 'listCountries', method: 'listCountries', endpoint: 'betting' },
  { name: 'listCompetitions', method: 'listCompetitions', endpoint: 'betting' },
  { name: 'listCurrentOrders', method: 'listCurrentOrders', endpoint: 'betting' },
  { name: 'listEvents', method: 'listEvents', endpoint: 'betting' },
  { name: 'listEventTypes', method: 'listEventTypes', endpoint: 'betting' },
  { name: 'listMarketBook', method: 'listMarketBook', endpoint: 'betting' },
  { name: 'listMarketCatalogue', method: 'listMarketCatalogue', endpoint: 'betting' },
  { name: 'placeOrders', method: 'placeOrders', endpoint: 'betting' },
  { name: 'replaceOrders', method: 'replaceOrders', endpoint: 'betting' },
  { name: 'updateOrders', method: 'updateOrders', endpoint: 'betting' },
  { name: 'getAccountFunds', method: 'getAccountFunds', endpoint: 'account' },
  { name: 'keepAlive', method: 'keepAlive', endpoint: 'identity' }
];

var getDescendantProp = function(obj, desc) {
  var arr = desc.split('.');
  while(arr.length && (obj = obj[arr.shift()]));
  return obj;
};

var api = {};

_.extend(api, {

  sessionToken: null,

  endpoints: {
    betting: {
      prefix: 'SportsAPING',
      version: 'v1.0',
      url: {
        uk: 'https://api.betfair.com/exchange/betting/json-rpc/v1',
        au: 'https://api-au.betfair.com/exchange/betting/json-rpc/v1'
      }
    },
    account: {
      prefix: 'AccountAPING',
      version: 'v1.0',
      url: {
        uk: 'https://api.betfair.com/exchange/account/json-rpc/v1',
        au: 'https://api-au.betfair.com/exchange/account/json-rpc/v1'
      }
    },
    identity: {
      prefix: '',
      version: '',
      url: 'https://identitysso-api.betfair.com:443/api'
    },
    auth: 'https://identitysso-api.betfair.com:443/api/certlogin'
  },

  login: function (callback) {
    var self = this;

    var getKey = function (complete) {
      return fs.readFile(self.certificateKeyLocation, complete);
    };

    var getCert = function (complete) {
      return fs.readFile(self.certificateLocation, complete);
    };

    // read in Key and Certificate
    async.parallel([ getKey, getCert ], function (err, certs) {
      if (err) {
        return callback(err);
      }

      // construct Request
      var req = {
        cert: certs[1],
        form: {
          username: self.bfu,
          password: self.bfp
        },
        gzip: true,
        headers: {
          'X-Application': 'LoginApp'
        },
        json: true,
        key: certs[0],
        method: 'POST',
        url: self.endpoints.auth
      };

      // send Request
      request(req, function (error, response, body) {
        if (error) {
          // an actual HTTP error.
          return callback(error);
        }

        if (_.isUndefined(response)) {
          return callback(new Error('Response is UNDEFINED'));
        }

        if (response.statusCode !== 200) {
          // a non-happy response code.
          return callback(new Error(response.statusCode));
        }

        if (body.loginStatus === 'SUCCESS') {
          self.sessionToken = body.sessionToken;
          return callback(null, true);
        }

        return callback(new Error(body));
      });
    });
  },

  createRequest: function (options, endpoint, method, next) {
    var self = this;

    var req = {
      body: JSON.stringify({
        id: 1,
        jsonrpc: '2.0',
        params: options,
        method: [
          this.endpoints[endpoint].prefix,
          this.endpoints[endpoint].version,
          method
        ].join('/')
      }),
      url: this.endpoints[endpoint].url[config.exchange.toLowerCase()],
      headers: {
        'X-Application': self.appKey
      },
      gzip: true,
      json: true,
      method: 'POST'
    };

    if (self.sessionToken === null) {
      self.login(function(err, loginResp) {
        if (err) {
          console.log(err);
          return next(err);
        }
        if (_.isUndefined(loginResp)) {
          return next(new Error('No Login Response'));
        }
        req.headers['X-Authentication'] = self.sessionToken;
        return next(null, req);
      });
    } else {
      req.headers['X-Authentication'] = self.sessionToken;
      return next(null, req);
    }
  },

  sendRequest: function (options, endpoint, method, callback) {
    this.createRequest(options, endpoint, method, function(err, req) {

      if (err) {
        return callback(err);
      }

      request(req, function (error, response, body) {
        var exception;
        var message;
        var code;

        if (error) {
          return callback(error);
        }

        if (_.isUndefined(response)) {
          return callback(new Error('response is undefined'));
        }

        if (body.result) {
          return callback(null, body.result);
        } else if (body.error) {
          if (body.error.data && body.error.data.APINGException) {
            exception = body.error.data.APINGException;
            message = exception.errorCode + (exception.errorDetails ? ': ' + exception.errorDetails : '');
            code = exception.errorCode;
          } else if (body.error.code) {
            code = body.error.code;
            message = body.error.message;
            if (!message) {
              switch (code) {
                case -32700:
                  message = 'Invalid JSON was received by the server. An error occurred on the server while parsing the JSON text.';
                  break;
                case -32601:
                  message = 'Method not found';
                  break;
                case -32602:
                  message = 'Problem parsing the parameters, or a mandatory parameter was not found';
                  break;
                case -32603:
                  message = 'Internal JSON-RPC error';
                  break;
              }
            }
          }
          return callback(new Error(message));
        } else if (response.statusCode !== 200) {
          switch (response.statusCode) {
            case 500:
              message = 'API is down';
              break;
            case 404:
              message = 'API Method was not found';
              break;
            case 400:
              message = 'BAD API request';
              break;
            default:
              message = response.statusText || 'API response HTTP status code: ' + response.statusCode;
              break;
          }
          return callback(new Error(message));
        } else {
          return callback(new Error('Unknown API Error'));
        }
      });
    });
  }
}, config);

// wire 'em up.
_.each(apiRequests, function(exRequest) {
  api[exRequest.name] = function(options, callback) {
    if (_.isUndefined(options)) {
      return callback(new Error('missing required params'));
    }

    var self = this;

    if (!(options && options.marketIds)) {
      return self.sendRequest(options, exRequest.endpoint, exRequest.method, callback);
    }

    // batch up request based on Option Filter Weightings
    var hasWeightedParam = false;
    var methodLimits = requestLimits[exRequest.method];
    var weight = 0;
    var marketsPerRequest;
    var filters = _.without(_.keys(methodLimits), 'applyTo', 'NONE');
    var filter = options;
    var marketIds = _.clone(options.marketIds);
    var marketIdBatches = [];
    var responses = [];

    if (methodLimits.applyTo) {
      filter = getDescendantProp(options, methodLimits.applyTo);
    }

    _.each(filters, function (weightedParam) {
      if (_.contains(filter, weightedParam)) {
        weight += methodLimits[weightedParam];
        hasWeightedParam = true;
      }
    });

    if (methodLimits.NONE && !hasWeightedParam) {
      weight += methodLimits.NONE;
    }

    marketsPerRequest = weight > 0 ? Math.floor(maxRequestLimit / weight) : 1;

    while (marketIds.length > 0) {
      marketIdBatches.push(marketIds.splice(0, marketsPerRequest));
    }

    async.each(marketIdBatches, function (marketIdBatch, nextBatch) {
      var req = _.clone(options);
      req.marketIds = marketIdBatch;
      self.sendRequest(req, exRequest.endpoint, exRequest.method, function (err, resp) {
        responses.push(resp);
        nextBatch(err);
      });
    }, function (err) {
      if (_.isUndefined(err)) err = null;
      return callback(err, _.flatten(responses, true));
    });
  };
});

module.exports = api;
